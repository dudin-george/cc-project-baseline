"""Pipeline state machine: step transitions, cascade-back, locking."""

from __future__ import annotations

import logging

from mycroft.shared.protocol import StepId, StepStatus, STEP_ORDER
from mycroft.server.state.project import ProjectState
from mycroft.server.state import conversation as conv

logger = logging.getLogger(__name__)


class PipelineError(Exception):
    pass


def _step_index(step_id: StepId) -> int:
    return STEP_ORDER.index(step_id)


def advance(project: ProjectState) -> StepId:
    """Lock current step and move to next. Returns new current step."""
    current = project.current_step
    idx = _step_index(current)

    if idx >= len(STEP_ORDER) - 1:
        raise PipelineError("Already at the last step.")

    current_state = project.steps[current]
    if current_state.status == StepStatus.PERMANENTLY_LOCKED:
        raise PipelineError(f"Step {current.value} is permanently locked.")

    # Lock current step (permanently if it's 2.2)
    if current == StepId.ARCHITECTURE_AUTO:
        current_state.status = StepStatus.PERMANENTLY_LOCKED
    else:
        current_state.status = StepStatus.LOCKED

    # Move to next
    next_step = STEP_ORDER[idx + 1]
    project.steps[next_step].status = StepStatus.DRAFT
    project.current_step = next_step

    project.save()
    logger.info("Pipeline advanced: %s → %s", current.value, next_step.value)
    return next_step


def go_back(project: ProjectState, target_step: StepId) -> StepId:
    """Go back to a target step, cascading removal of all downstream state."""
    current = project.current_step
    target_idx = _step_index(target_step)
    current_idx = _step_index(current)

    if target_idx >= current_idx:
        raise PipelineError(f"Cannot go back to {target_step.value} — not a previous step.")

    # Check permanent lock: if 2.2 is permanently locked and target is before it, reject
    arch_auto = project.steps[StepId.ARCHITECTURE_AUTO]
    if arch_auto.status == StepStatus.PERMANENTLY_LOCKED:
        if target_idx <= _step_index(StepId.ARCHITECTURE_AUTO):
            raise PipelineError(
                "Cannot go back past Step 2.2 — it is permanently locked."
            )

    # Cascade: remove all steps from target+1 through current
    for i in range(target_idx + 1, current_idx + 1):
        step_id = STEP_ORDER[i]
        project.steps[step_id].status = StepStatus.DRAFT
        conv.delete_conversation(project.project_dir, step_id)
        # Also remove documents for this step
        _remove_step_documents(project, step_id)

    # Reopen target step
    project.steps[target_step].status = StepStatus.DRAFT
    project.current_step = target_step

    project.save()
    logger.info("Pipeline went back to step %s (cascade from %s)", target_step.value, current.value)
    return target_step


def _remove_step_documents(project: ProjectState, step_id: StepId) -> None:
    """Remove documents generated by a step."""
    docs_dir = project.project_dir / "docs"
    if not docs_dir.exists():
        return

    doc_map: dict[StepId, list[str]] = {
        StepId.IDEA_SCOPING: ["00-idea.md"],
        StepId.USE_CASES_MANUAL: ["01-use-cases.md"],
        StepId.USE_CASES_AUTO: ["01-use-cases.md", "01-use-case-diagram.mmd"],
        StepId.ARCHITECTURE_MANUAL: ["02-architecture.md"],
        StepId.ARCHITECTURE_AUTO: ["02-architecture.md"],
        StepId.PROJECT_SETUP: [],
        StepId.C4_DESIGN: [],
        StepId.WORK_PLANNING: [],
        StepId.EXECUTION: [],
        StepId.E2E_TESTING: [],
    }

    for filename in doc_map.get(step_id, []):
        (docs_dir / filename).unlink(missing_ok=True)

    # Remove service specs for step 2.2
    if step_id == StepId.ARCHITECTURE_AUTO:
        services_dir = docs_dir / "services"
        if services_dir.exists():
            for f in services_dir.iterdir():
                f.unlink()

    # Remove C4 Level 4 design docs for step 3.2
    if step_id == StepId.C4_DESIGN:
        design_dir = docs_dir / "03-design"
        if design_dir.exists():
            for f in design_dir.iterdir():
                f.unlink()


def get_step_documents(project: ProjectState, step_id: StepId) -> dict[str, str]:
    """Read all documents produced by a step."""
    docs_dir = project.project_dir / "docs"
    result: dict[str, str] = {}
    if not docs_dir.exists():
        return result

    doc_map: dict[StepId, list[str]] = {
        StepId.IDEA_SCOPING: ["00-idea.md"],
        StepId.USE_CASES_MANUAL: ["01-use-cases.md"],
        StepId.USE_CASES_AUTO: ["01-use-cases.md", "01-use-case-diagram.mmd"],
        StepId.ARCHITECTURE_MANUAL: ["02-architecture.md"],
        StepId.ARCHITECTURE_AUTO: ["02-architecture.md"],
        StepId.PROJECT_SETUP: [],
        StepId.C4_DESIGN: [],
        StepId.WORK_PLANNING: [],
        StepId.EXECUTION: [],
        StepId.E2E_TESTING: [],
    }

    for filename in doc_map.get(step_id, []):
        path = docs_dir / filename
        if path.exists():
            result[filename] = path.read_text()

    # Include service specs for 2.2
    if step_id == StepId.ARCHITECTURE_AUTO:
        services_dir = docs_dir / "services"
        if services_dir.exists():
            for f in sorted(services_dir.iterdir()):
                if f.suffix == ".md":
                    result[f"services/{f.name}"] = f.read_text()

    # Include C4 Level 4 design docs for 3.2
    if step_id == StepId.C4_DESIGN:
        design_dir = docs_dir / "03-design"
        if design_dir.exists():
            for f in sorted(design_dir.iterdir()):
                if f.suffix == ".md":
                    result[f"03-design/{f.name}"] = f.read_text()

    return result


def get_all_previous_documents(project: ProjectState) -> dict[str, str]:
    """Collect all documents from steps before the current one."""
    current_idx = _step_index(project.current_step)
    result: dict[str, str] = {}
    for i in range(current_idx):
        step_id = STEP_ORDER[i]
        result.update(get_step_documents(project, step_id))
    return result
